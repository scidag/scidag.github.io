



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="scidag" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="scidag" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="scidag" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://example.com/2025/07/14/demo6-1/">



  <title>
MySQL |
scidag的个人博客 = scidag = litao</title>
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">MySQL
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2025-07-14 22:17:45">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2025-07-14T22:17:45+08:00">2025-07-14</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">scidag的个人博客</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicm07ih54j20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciusoyjnj219g0u0x56.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclffsa1cj20zk0m811l.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/14/demo6-1/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/myavatar.jpg">
    <meta itemprop="name" content="李涛">
    <meta itemprop="description" content="litao, 李涛的个人博客">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="scidag">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h4 id="1概述"><a class="markdownIt-Anchor" href="#1概述">#</a> 1. 概述</h4>
<p>​	MySQL 数据库</p>
<p>​	数据模型</p>
<p>​			在 DBMS 中可以创建多个数据库  ，数据库中可以创建多个表</p>
<h4 id="2sql"><a class="markdownIt-Anchor" href="#2sql">#</a> 2.SQL</h4>
<p>​	分类</p>
<p>​</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDL</td>
<td>Date Definition Language</td>
<td>数据定义语言 ，用来定义数据库对象（数据库，表，字段）</td>
</tr>
<tr>
<td>DML</td>
<td>Date Manipulation Language</td>
<td>数据操作语言，用来对数据库中表的数据进行增  删  改</td>
</tr>
<tr>
<td>DQL</td>
<td>Date Query   Language</td>
<td>数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Date Control Language</td>
<td>数据控制语言，用来创建数据库用户，控制数据库的访问权限</td>
</tr>
</tbody>
</table>
<h5 id="1ddl"><a class="markdownIt-Anchor" href="#1ddl">#</a> 1.DDL</h5>
<h6 id="1-查询所有数据库"><a class="markdownIt-Anchor" href="#1-查询所有数据库">#</a> 1). 查询所有数据库</h6>
<p>show databases ;</p>
<h6 id="2-查询当前数据库"><a class="markdownIt-Anchor" href="#2-查询当前数据库">#</a> 2). 查询当前数据库</h6>
<p>select database() ;</p>
<h6 id="3-创建数据库"><a class="markdownIt-Anchor" href="#3-创建数据库">#</a> 3). 创建数据库</h6>
<p>create database [if not exists] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</p>
<h6 id="4删除数据库"><a class="markdownIt-Anchor" href="#4删除数据库">#</a> 4）删除数据库</h6>
<p>drop database [if  exists] 数据库名</p>
<h6 id="5切换数据库"><a class="markdownIt-Anchor" href="#5切换数据库">#</a> 5）切换数据库</h6>
<p>use　		数据库名</p>
<h6 id="6创建表结构"><a class="markdownIt-Anchor" href="#6创建表结构">#</a> ６）创建表结构</h6>
<p>CREATE TABLE 表名 (<br>
字段 1 字段 1 类型 [ COMMENT 字段 1 注释],<br>
 字段 2 字段 2 类型 [COMMENT 字段 2 注释],<br>
 字段 3 字段 3 类型 [COMMENT 字段 3 注释],<br>
…<br>
 字段 n 字段 n 类型 [COMMENT 字段 n 注释]<br>
) [COMMENT 表注释] ;</p>
<p>查看表结构　desc  表名</p>
<p>show create table table_name;</p>
<h6 id="7修改表结构"><a class="markdownIt-Anchor" href="#7修改表结构">#</a> 7）修改表结构</h6>
<p>​	添加字段</p>
<p>​		ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</p>
<p>​	修改字段名和字段类型</p>
<p>​		ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度);</p>
<p>​	删除字段名</p>
<p>​		ALTER TABLE 表名 DROP 字段名；</p>
<p>​	修改表名</p>
<p>​		ALTER TABLE 表名 RENAME TO 新表名；</p>
<h6 id="8删除表"><a class="markdownIt-Anchor" href="#8删除表">#</a> 8）删除表</h6>
<ul>
<li>
<p>​		删除表</p>
<p>​		DROP TABLE [IF EXISTS] 表名；.</p>
</li>
<li>
<p>删除指定表</p>
<p>​		TRUNCATE TABLE 表名；</p>
</li>
</ul>
<h5 id="2dml-insert-update-delete"><a class="markdownIt-Anchor" href="#2dml-insert-update-delete">#</a> 2.DML （insert  update  delete）</h5>
<h6 id="insert"><a class="markdownIt-Anchor" href="#insert">#</a> insert</h6>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);  <span class="comment">-- 这是部分字段</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);   <span class="comment">-- 这是全部字段 </span></span><br></pre></td></tr></table></figure>
<h6 id="update"><a class="markdownIt-Anchor" href="#update">#</a> update</h6>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span> , 字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span> , .... [ <span class="keyword">WHERE</span> 条件 ] ;</span><br></pre></td></tr></table></figure>
<h6 id="delete"><a class="markdownIt-Anchor" href="#delete">#</a> delete</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [ WHERE 条件 ] ;</span><br></pre></td></tr></table></figure>
<h5 id="3dql"><a class="markdownIt-Anchor" href="#3dql">#</a> 3.DQL</h5>
<h6 id="select"><a class="markdownIt-Anchor" href="#select">#</a> select</h6>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>基本查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段名  <span class="keyword">from</span> 表名  <span class="comment">--可以去除重复的字段</span></span><br></pre></td></tr></table></figure>
<p>1). 语法</p>
<p>SELECT 字段列表 FROM 表名 WHERE 条件列表</p>
<blockquote>
<p>大于<br>
 = 大于等于<br>
 &lt; 小于<br>
 &lt;= 小于等于<br>
 = 等于<br>
 &lt;&gt; 或！= 不等于<br>
 BETWEEN … AND … 在某个范围之内 (含最小、最大值)<br>
 IN (…) 在 in 之后的列表中的值，多选一<br>
 LIKE 占位符 模糊匹配 (_匹配单个字符，% 匹配任意个字符)<br>
 IS NULL 是 NULL<br>
 逻辑运算符 功能<br>
 AND 或 &amp;&amp; 并且 (多个条件同时成立)<br>
 OR 或 || 或者 (多个条件任意一个成立)<br>
 NOT 或！非，不是</p>
</blockquote>
<p>2. 聚合函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
<tr>
<td>注：null 不参与聚合函数运算</td>
<td></td>
</tr>
</tbody>
</table>
<p>3. 分组查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [ <span class="keyword">WHERE</span> 条件 ] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [ <span class="keyword">HAVING</span> 分组</span><br><span class="line">后过滤条件 ];</span><br></pre></td></tr></table></figure>
<p>注意事项:<br>
・分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。<br>
・执行顺序: where &gt; 聚合函数 &gt; having 。<br>
・支持多字段分组，具体语法为 : group by columnA,columnB</p>
<p>4. 排序查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span> , 字段<span class="number">2</span> 排序方式<span class="number">2</span> ;</span><br></pre></td></tr></table></figure>
<p>2). 排序方式<br>
 ASC : 升序 (默认值)<br>
 DESC: 降序<br>
注意事项：<br>
・如果是升序，可以不指定排序方式 ASC ;<br>
・如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序；</p>
<p>5 分页查询</p>
<p>limit</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数 ;</span><br></pre></td></tr></table></figure>
<p>注意事项:<br>
・起始索引从 0 开始，起始索引 = （查询页码 - 1）* 每页显示记录数。<br>
・分页查询是数据库的方言，不同的数据库有不同的实现，MySQL 中是 LIMIT。<br>
・如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p>
<h5 id="4dcl"><a class="markdownIt-Anchor" href="#4dcl">#</a> 4.DCL</h5>
<p>1). 查询用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mysql.user;</span><br></pre></td></tr></table></figure>
<p>2) 创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure>
<p>3) 修改用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27; ;</span><br></pre></td></tr></table></figure>
<p>4). 删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27; ;</span><br></pre></td></tr></table></figure>
<p>注意事项:<br>
・在 MySQL 中需要通过用户名 @主机名的方式，来唯一标识一个用户。</p>
<p>・主机名可以使用 % 通配。<br>
・这类 SQL 开发人员操作的比较少，主要是 DBA（ Database Administrator 数据库<br>
管理员）使用。</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALL, ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库 / 表 / 视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库 / 表</td>
</tr>
</tbody>
</table>
<p>1). 查询权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; ;</span><br></pre></td></tr></table></figure>
<p>2). 授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;1</span><br></pre></td></tr></table></figure>
<p>3). 撤销权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>
・多个权限之间，使用逗号分隔<br>
・授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p>
<h4 id="3函数"><a class="markdownIt-Anchor" href="#3函数">#</a> 3. 函数</h4>
<h6 id="1字符串函数"><a class="markdownIt-Anchor" href="#1字符串函数">#</a> 1. 字符串函数</h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT(S1,S2,…Sn)</td>
<td>字符串拼接，将 S1，S2，… Sn 拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串 str 全部转为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串 str 全部转为大写</td>
</tr>
<tr>
<td>LPAD(str,n,pad)</td>
<td>左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符<br/>串长度</td>
</tr>
<tr>
<td>RPAD(str,n,pad)</td>
<td>右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符<br/>串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str,start,len)</td>
<td>返回从字符串 str 从 start 位置起的 len 个长度的字符串</td>
</tr>
</tbody>
</table>
<p>使用就是 select 后直接加函数</p>
<h6 id="2数值函数"><a class="markdownIt-Anchor" href="#2数值函数">#</a> 2. 数值函数</h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回 x/y 的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回 0~1 内的随机数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>求参数 x 的四舍五入的值，保留 y 位小数</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#生成一个<span class="number">6</span>位t验证码</span><br><span class="line"><span class="keyword">select</span> LPAD(round(rand()<span class="operator">*</span><span class="number">1000000</span>,<span class="number">0</span>),<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">#计算员工在职天数</span><br><span class="line"><span class="keyword">select</span>   name, DATEDIFF(curdate(), entrydate) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<h6 id="3日期函数"><a class="markdownIt-Anchor" href="#3日期函数">#</a> 3. 日期函数</h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定 date 的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定 date 的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定 date 的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr<br/>type)</td>
<td>返回一个日期 / 时间值加上一个时间间隔 expr 后的<br/>时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回起始时间 date1 和 结束时间 date2 之间的天<br/>数</td>
</tr>
</tbody>
</table>
<h6 id="4流程函数"><a class="markdownIt-Anchor" href="#4流程函数">#</a> 4. 流程函数</h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF(value , t , f)</td>
<td>如果 value 为 true，则返回 t，否则返回<br/>f</td>
</tr>
<tr>
<td>IFNULL(value1 , value2)</td>
<td>如果 value1 不为空，返回 value1，否则<br/>返回 value2</td>
</tr>
<tr>
<td>CASE WHEN [ val1 ] THEN [res1] …<br/>ELSE [ default ] END</td>
<td>如果 val1 为 true，返回 res1，… 否<br/>则返回 default 默认值</td>
</tr>
<tr>
<td>CASE [ expr ] WHEN [ val1 ] THEN<br/>[res1] … ELSE [ default ] END</td>
<td>如果 expr 的值等于 val1，返回 res1，… 否则返回 default 默认值</td>
</tr>
</tbody>
</table>
<h4 id="4约束"><a class="markdownIt-Anchor" href="#4约束">#</a> 4. 约束</h4>
<p>作用于表中字段的规则，限制存储在表中的数据</p>
<p>可以保证数据库中的正确性，有效性完整性</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段的数据不能为 null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束 (8.0.16 版本<br/>之后)</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致<br/>性和完整性</td>
<td>FOREIGN<br/>KEY</td>
</tr>
</tbody>
</table>
<p>注意：约束是作用于表中字段上的，可以在创建表 / 修改表的时候添加约束</p>
<p>外键约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN KEY</span> (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br><span class="line">);  <span class="comment">--创建表时的添加外键约束</span></span><br><span class="line"> <span class="comment">-- 创建完成后添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN KEY</span> (外键字段名)</span><br><span class="line"><span class="keyword">REFERENCES</span> 主表 (主表列名) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除外键约束</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> 外键名称;</span><br></pre></td></tr></table></figure>
<p>CASCADE<br>
 当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有，则<br>
也删除 / 更新外键在子表中的记录。</p>
<p>具体语法为:<br>
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES<br>
 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</p>
<h4 id="5多表查询"><a class="markdownIt-Anchor" href="#5多表查询">#</a> 5. 多表查询</h4>
<h6 id="1多表关系"><a class="markdownIt-Anchor" href="#1多表关系">#</a> 1. 多表关系</h6>
<p>​		一对多</p>
<p>​				多的一方建立外键，指向一的逐渐</p>
<p>​		多对多</p>
<p>​				建立第三张中间表，中间表包括两条主键</p>
<p>​		一对一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多用于单表拆分，将基础字段放一张表，其他详情字段放在另一张表中，以提升操作效率</span><br><span class="line">实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</span><br></pre></td></tr></table></figure>
<h6 id="2多表查询"><a class="markdownIt-Anchor" href="#2多表查询">#</a> 2. 多表查询</h6>
<p>​			多表查询需要删除无效的笛卡儿积</p>
<p><strong>内连接</strong></p>
<p>​		1. 隐式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</span><br></pre></td></tr></table></figure>
<p>​		2. 显式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</span><br></pre></td></tr></table></figure>
<p><strong>外连接</strong></p>
<p>​		1. 左外连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br></pre></td></tr></table></figure>
<p>​		2. 右外连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br></pre></td></tr></table></figure>
<p><strong>自连接</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表A 别名B <span class="keyword">ON</span> 条件 ... ;</span><br></pre></td></tr></table></figure>
<p><strong>联合查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ ALL ] -- 不行all,则会去重</span><br><span class="line">SELECT 字段列表 FROM 表B ....</span><br></pre></td></tr></table></figure>
<p><strong>子查询</strong></p>
<p>根据子查询结果不同，分为：<br>
A. 标量子查询（子查询结果为单个值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</span><br></pre></td></tr></table></figure>
<p>常用的操作符：= &lt;&gt;&gt; &gt;= &lt; &lt;=</p>
<p>B. 列子查询 (子查询结果为一列)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</span><br></pre></td></tr></table></figure>
<p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p>
<p>C. 行子查询 (子查询结果为一行)</p>
<p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。<br>
常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p>
<p>D. 表子查询 (子查询结果为多行多列)</p>
<p>子查询返回的结果是多行多列，这种子查询称为表子查询。<br>
常用的操作符：IN</p>
<h4 id="6事务"><a class="markdownIt-Anchor" href="#6事务">#</a> 6. 事务</h4>
<h6 id="1简介"><a class="markdownIt-Anchor" href="#1简介">#</a> 1. 简介</h6>
<p>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系<br>
统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<h6 id="2事务操作"><a class="markdownIt-Anchor" href="#2事务操作">#</a> 2. 事务操作</h6>
<p>1). 查看 / 设置事务提交方式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span> ;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION 或 <span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure>
<p>2). 提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>3). 回滚事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
<p>注意：上述的这种方式，我们是修改了事务的自动提交行为，把默认的自动提交修改为了手动提<br>
交，此时我们执行的 DML 语句都不会提交，需要手动的执行 commit 进行提交。</p>
<h6 id="3事务的四大特性"><a class="markdownIt-Anchor" href="#3事务的四大特性">#</a> 3. 事务的四大特性</h6>
<p>原子性（Atomicity）： 事务是不可分割的最小操作单元，要么全执行成功，要么全失败</p>
<p>一致性（Consistency）: 事务完成时，必须使所有的数据保持一致状态</p>
<p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立<br>
环境下运行。<br>
持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p>
<h6 id="4并发事务问题"><a class="markdownIt-Anchor" href="#4并发事务问题">#</a> 4. 并发事务问题</h6>
<p>1). 赃读：一个事务读到另外一个事务还没有提交的数据。<br>
2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p>
<p>3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据<br>
已经存在，好像出现了 “幻影”。</p>
<h6 id="5事务的隔离级别"><a class="markdownIt-Anchor" href="#5事务的隔离级别">#</a> 5. 事务的隔离级别</h6>
<p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p>
<p>隔离级别 						脏读 			不可重复读 			幻读<br>
 Read uncommitted	 √ 						√ 							√<br>
Read committed 		× 						√ 							√<br>
Repeatable Read (默认) × 						×							 √<br>
Serializable					 × 						×							 ×</p>
<p>1). 查看事务隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br></pre></td></tr></table></figure>
<p>2.）设置事务隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED |</span><br><span class="line">READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;</span><br></pre></td></tr></table></figure>
<p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p>
<h2 id="二进阶"><a class="markdownIt-Anchor" href="#二进阶">#</a> 二。进阶</h2>
<h4 id="1存储引擎"><a class="markdownIt-Anchor" href="#1存储引擎">#</a> 1. 存储引擎</h4>
<h5 id="11-mysql体系结构"><a class="markdownIt-Anchor" href="#11-mysql体系结构">#</a> 1.1 MySQL 体系结构</h5>
<p>1). 连接层         主要处理客户端的连接授权，校验，认证</p>
<p>2). 服务层			主要 sql 解析，优化</p>
<p>3). 引擎层            索引，不同引擎索引不同</p>
<p>4). 存储层				存储索引日志文件</p>
<h5 id="12-存储引擎介绍"><a class="markdownIt-Anchor" href="#12-存储引擎介绍">#</a> 1.2 存储引擎介绍</h5>
<p><img data-src="C:%5CUsers%5Clx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1741139642082.png" alt="1741139642082"></p>
<h5 id="13innodb"><a class="markdownIt-Anchor" href="#13innodb">#</a> 1.3Innodb</h5>
<h6 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍">#</a> 1). 介绍</h6>
<p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的<br>
 MySQL 存储引擎。</p>
<h6 id="2-特点"><a class="markdownIt-Anchor" href="#2-特点">#</a> 2). 特点</h6>
<p>DML 操作遵循 ACID 模型，支持事务；<br>
行级锁，提高并发访问性能；<br>
支持外键 FOREIGN KEY 约束，保证数据的完整性和正确性；</p>
<h6 id="3-文件"><a class="markdownIt-Anchor" href="#3-文件">#</a> 3). 文件</h6>
<p>xxx.ibd：xxx 代表的是表名，innoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结<br>
构（frm - 早期的 、sdi - 新版的）、数据和索引。<br>
参数：innodb_file_per_table</p>
<h6 id="4-逻辑存储结构"><a class="markdownIt-Anchor" href="#4-逻辑存储结构">#</a> 4). 逻辑存储结构</h6>
<p>​	表空间 : InnoDB 存储引擎逻辑结构的最高层，ibd 文件其实就是表空间文件，在表空间中可以<br>
包含多个 Segment 段。<br>
​	段：表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB 中对于段的管<br>
理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。<br>
​	区：区是表空间的单元结构，每个区的大小为 1M。 默认情况下， InnoDB 存储引擎页大小为<br>
 16K， 即一个区中一共有 64 个连续的页。<br>
​	页：页是组成区的最小单元，页也是 InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默<br>
认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。<br>
​	行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时<br>
所指定的字段以外，还包含两个隐藏字段 (后面会详细介绍)</p>
<h5 id="14-myisam"><a class="markdownIt-Anchor" href="#14-myisam">#</a> 1.4   MyISAM</h5>
<h6 id="1-介绍-2"><a class="markdownIt-Anchor" href="#1-介绍-2">#</a> 1). 介绍</h6>
<p>MyISAM 是 MySQL 早期的默认存储引擎。</p>
<h6 id="2-特点-2"><a class="markdownIt-Anchor" href="#2-特点-2">#</a> 2). 特点</h6>
<p>不支持事务，不支持外键<br>
支持表锁，不支持行锁<br>
访问速度快</p>
<h6 id="3-文件-2"><a class="markdownIt-Anchor" href="#3-文件-2">#</a> 3). 文件</h6>
<p>xxx.sdi：存储表结构信息<br>
 xxx.MYD: 存储数据<br>
 xxx.MYI: 存储索引</p>
<h5 id="15memory"><a class="markdownIt-Anchor" href="#15memory">#</a> 1.5Memory</h5>
<h6 id="1-介绍-3"><a class="markdownIt-Anchor" href="#1-介绍-3">#</a> 1). 介绍</h6>
<p>Memory 引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为<br>
临时表或缓存使用。</p>
<h6 id="2-特点-3"><a class="markdownIt-Anchor" href="#2-特点-3">#</a> 2). 特点</h6>
<p>内存存放<br>
 hash 索引（默认）</p>
<h6 id="3文件"><a class="markdownIt-Anchor" href="#3文件">#</a> 3). 文件</h6>
<p>xxx.sdi：存储表结构信息</p>
<h5 id="16区别及特点面试题"><a class="markdownIt-Anchor" href="#16区别及特点面试题">#</a> 1.6 区别及特点 (面试题)</h5>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td><strong>支持</strong></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td><strong>行锁</strong></td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持 (5.6 版本之后)</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td><strong>支持</strong></td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h5 id="17-存储引擎选择"><a class="markdownIt-Anchor" href="#17-存储引擎选择">#</a> 1.7 存储引擎选择</h5>
<p>​		在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据<br>
​		实际情况选择多种存储引擎进行组合。<br>
​		InnoDB: 是 Mysql 的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要<br>
求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操<br>
作，那么 InnoDB 存储引擎是比较合适的选择。<br>
​			MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完<br>
整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。<br>
​			MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY 的缺陷就是<br>
对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p>
<h4 id="2索引"><a class="markdownIt-Anchor" href="#2索引">#</a> 2. 索引</h4>
<p>​	索引（index）是帮助 MySQL 高效获取数据的数据结构 (有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<h5 id="21优缺点"><a class="markdownIt-Anchor" href="#21优缺点">#</a> 2.1 优缺点</h5>
<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td>提高数据检索的效率，降低数据库<br/>的 IO 成本</td>
<td>索引列也是要占用空间的。</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低<br/>数据排序的成本，降低 CPU 的消<br/>耗。</td>
<td>索引大大提高了查询效率，同时却也降低更新表的速度，<br/>如对表进行 INSERT、UPDATE、DELETE 时，效率降低。</td>
</tr>
</tbody>
</table>
<h5 id="22索引结构"><a class="markdownIt-Anchor" href="#22索引结构">#</a> 2.2 索引结构</h5>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6 版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//面试题   为什么InnoDB存储引擎选择使用B+tree索引结构?</span><br><span class="line">A. 相对于二叉树，层级更少，搜索效率高；</span><br><span class="line">B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储</span><br><span class="line">的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</span><br><span class="line">C. 相对Hash索引，B+tree支持范围匹配及排序操作；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="23索引分类"><a class="markdownIt-Anchor" href="#23索引分类">#</a> 2.3 索引分类</h5>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能<br/>有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一<br/>索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规<br/>索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文<br/>索引</td>
<td>全文索引查找的是文本中的关键词，而不是比<br/>较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody>
</table>
<h5 id="24-聚集索引二级索引"><a class="markdownIt-Anchor" href="#24-聚集索引二级索引">#</a> 2.4 聚集索引 &amp; 二级索引</h5>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚集索引 (Clustered<br/>Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子<br/>节点保存了行数据</td>
<td>必须有，而且只<br/>有一个</td>
</tr>
<tr>
<td>二级索引 (Secondary<br/>Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关<br/>联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody>
</table>
<p>​</p>
<p>聚集索引选取规则:<br>
 如果存在主键，主键索引就是聚集索引。</p>
<p>​	如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。<br>
​	如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索<br>
引</p>
<h5 id="25索引语法"><a class="markdownIt-Anchor" href="#25索引语法">#</a> 2.5 索引语法</h5>
<p>1). 创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (</span><br><span class="line">index_col_name,... ) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2). 查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3). 删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="26-sql性能分析"><a class="markdownIt-Anchor" href="#26-sql性能分析">#</a> 2.6 SQL 性能分析</h5>
<p>2.6.1 SQL 执行频率<br>
 MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信<br>
息。通过如下指令，可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;  <span class="comment">-- Com_delete: 删除次数  </span></span><br><span class="line"><span class="comment">-- Com_insert: 插入次数</span></span><br><span class="line"><span class="comment">-- Com_select: 查询次数</span></span><br><span class="line"><span class="comment">-- Com_update: 更新次数 --</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>慢查询日志</li>
</ul>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有<br>
 SQL 语句的日志</p>
<p>MySQL 的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="27profile详情"><a class="markdownIt-Anchor" href="#27profile详情">#</a> 2.7profile 详情</h5>
<p>show profiles 能够在做 SQL 优化时帮助我们了解时间都耗费到哪里去了。通过 have_profiling<br>
 参数，能够看到当前 MySQL 是否支持 profile 操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have_profiling</span> ;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@profiling</span> ;  <span class="comment">--可以看到，当前MySQL是支持 profile操作--- 的，但是开关是关闭的。可以通过set语句在</span></span><br><span class="line"><span class="comment">-- session/global级别开启profiling</span></span><br><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 通过这个开启profiling</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> 查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句CPU的使用情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="28-explain"><a class="markdownIt-Anchor" href="#28-explain">#</a> 2.8 explain</h5>
<p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行<br>
过程中表如何连接和连接的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 直接在select语句之前加上关键字 explain / desc</span><br><span class="line">EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>select 查询的序列号，表示查询中执行 select 子句或者是操作表的顺序<br/>(id 相同，执行顺序从上到下；id 不同，值越大，越先执行)。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接<br/>或者子查询）、PRIMARY（主查询，即外层的查询）、<br/>UNION（UNION 中的第二个或者后面的查询语句）、<br/>SUBQUERY（SELECT/WHERE 之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为 NULL、system、const、<br/>eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为 NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长<br/>度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL 认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值，<br/>可能并不总是准确的。</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
</tbody>
</table>
<h5 id="29-索引使用"><a class="markdownIt-Anchor" href="#29-索引使用">#</a> 2.9 索引使用</h5>
<h6 id="291最左前缀法则"><a class="markdownIt-Anchor" href="#291最左前缀法则">#</a> 2.9.1 最左前缀法则</h6>
<p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，<br>
并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效 (后面的字段索引失效)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当执行SQL语句: explain select * from tb_user where age = 31 and</span><br><span class="line">status = &#x27;0&#x27; and profession = &#x27;软件工程&#x27;； 时，是否满足最左前缀法则，走不走</span><br><span class="line">上述的联合索引，索引长度？</span><br><span class="line">可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</span><br><span class="line">注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是</span><br><span class="line">第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="292范围查询"><a class="markdownIt-Anchor" href="#292范围查询">#</a> 2.9.2 范围查询</h6>
<p>联合索引中，出现范围查询 (&gt;,&lt;)，范围查询右侧的列索引失效。</p>
<ul>
<li>索引失效情况</li>
</ul>
<p>不要在索引列上进行运算操作， 索引将失效。</p>
<ul>
<li>字符串不加引号</li>
</ul>
<p>字符串类型字段使用时，不加引号，索引将失效</p>
<ul>
<li>​			模糊查询</li>
</ul>
<p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p>
<ul>
<li>or 连接条件</li>
</ul>
<p>用 or 分割开的条件， 如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
<ul>
<li>数据分布影响</li>
</ul>
<p>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</p>
<ul>
<li>​    SQL 提示</li>
</ul>
<p>是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优<br>
化操作的目的。<br>
1). use index ： 建议 MySQL 使用哪一个索引完成此次查询（仅仅是建议，mysql 内部还会再次进<br>
行评估）。<br>
2). ignore index ： 忽略指定的索引。<br>
3). force index ： 强制使用索引。</p>
<ul>
<li>
<p>覆盖索引</p>
<p>尽量使用覆盖索引，减少 select *。</p>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Using where; Using<br/>Index</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需<br/>要回表查询数据</td>
</tr>
<tr>
<td>Using index<br/>condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>前缀索引</p>
</li>
</ul>
<p>当字段类型为字符串（varchar，text，longtext 等）时，有时候需要索引很长的字符串，这会让<br>
索引变得很大，查询时，浪费大量的磁盘 IO， 影响查询效率。此时可以只将字符串的一部分前缀，建<br>
立索引，这样可以大大节约索引空间，从而提高索引效率</p>
<p>1.) 语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index idx_xxxx on table_name(column(n)) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2). 前缀长度（使用场景：字符串较长，文本较多）<br>
可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，<br>
索引选择性越高则查询效率越高， 唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user ;</span><br><span class="line">select count(distinct substring(email,1,5)) / count(*) from tb_user ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="210单列索引与联合索引"><a class="markdownIt-Anchor" href="#210单列索引与联合索引">#</a> 2.10 单列索引与联合索引</h5>
<p>单列索引：即一个索引只包含单个列。<br>
联合索引：即一个索引包含了多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<h5 id="211索引设计原则"><a class="markdownIt-Anchor" href="#211索引设计原则">#</a> 2.11 索引设计原则</h5>
<p>针对表数据量较多</p>
<p>1). 针对于数据量较大，且查询比较频繁的表建立索引。<br>
2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索<br>
引。<br>
3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。<br>
4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。<br>
5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，<br>
避免回表，提高查询效率。<br>
6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增<br>
删改的效率</p>
<p>7). 如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含<br>
 NULL 值时，它可以更好地确定哪个索引最有效地用于查询</p>
<h4 id="3sql优化"><a class="markdownIt-Anchor" href="#3sql优化">#</a> 3.SQL 优化</h4>
<h5 id="31插入数据"><a class="markdownIt-Anchor" href="#31插入数据">#</a> 3.1 插入数据</h5>
<p>​		插入大量数据是，使用 insert 时耗时较长，所以使用 load 指令，操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 客户端连接服务端时，加上参数 -–local-infile</span></span><br><span class="line">mysql –<span class="operator">-</span><span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields</span><br><span class="line">terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="32主键优化"><a class="markdownIt-Anchor" href="#32主键优化">#</a> 3.2 主键优化</h5>
<p>1). 数据组织方式<br>
在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表<br>
 (index organized table IOT)</p>
<p>2). 页分裂<br>
页可以为空，也可以填充一半，也可以填充 100%。每个页包含了 2-N 行数据 (如果一行数据过大，会行<br>
溢出)，根据主键排列。</p>
<p>3). 页合并</p>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间<br>
变得允许被其他记录声明使用。</p>
<p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的 50%），InnoDB 会开始寻找最靠近的页（前<br>
或后）看看是否可以将两个页合并以优化空间使用。</p>
<p>4). 索引设计原则<br>
满足业务需求的情况下，尽量降低主键的长度。<br>
插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键。尽量不要使用 UUID 做主键或者是其他自然主键，如身份证号。<br>
业务操作时，避免对主键的修改</p>
<h5 id="33order-by优化"><a class="markdownIt-Anchor" href="#33order-by优化">#</a> 3.3order by 优化</h5>
<p>MySQL 的排序，有两种方式：<br>
Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort<br>
buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。<br>
Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要<br>
额外排序，操作效率高。<br>
对于以上的两种排序方式，Using index 的性能高，而 Using filesort 的性能低，我们在优化排序<br>
操作时，尽量要优化为 Using index。</p>
<p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。<br>
B. 尽量使用覆盖索引。<br>
C. 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。<br>
D. 如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小<br>
 sort_buffer_size (默认 256k)。</p>
<h5 id="34group-by"><a class="markdownIt-Anchor" href="#34group-by">#</a> 3.4group by</h5>
<p>对于分组操作，<br>
在联合索引中，也是符合最左前缀法则的。<br>
所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：<br>
A. 在分组操作时，可以通过索引来提高效率。<br>
B. 分组操作时，索引的使用也是满足最左前缀法则的。</p>
<h5 id="35-limit"><a class="markdownIt-Anchor" href="#35-limit">#</a> 3.5 limit</h5>
<p>优化思路：一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查<br>
询形式进行优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_sku t , (select id from tb_sku order by id</span><br><span class="line">limit 2000000,10) a where t.id = a.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.6count 优化</p>
<p>count () 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是<br>
 NULL，累计值就加 1，否则不加，最后返回累计值。<br>
用法：count（*）、count（主键）、count（字段）、count（数字</p>
<p>count (主键)<br>
 InnoDB 引擎会遍历整张表，把每一行的 主键 id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加 (主键不可能为 null)<br>
 count (字段)<br>
 没有 not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出<br>
来，返回给服务层，服务层判断是否为 null，不为 null，计数累加。<br>
有 not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。<br>
count (数字)<br>
 InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字 “1”<br>
 进去，直接按行进行累加。<br>
count(*)<br>
 InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接<br>
按行进行累加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽</span><br><span class="line">量使用 count(*)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.6update 优化</p>
<p>​		更新时 where 条件尽量使用 带索引的・，否则会使行锁升级为表锁，降低性能</p>
<p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁<br>
升级为表锁 。</p>
<h4 id="4视图存储过程触发器"><a class="markdownIt-Anchor" href="#4视图存储过程触发器">#</a> 4. 视图，存储过程，触发器</h4>
<p>4.1 视图<br>
 4.1.1 介绍<br>
视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>
通俗的讲，视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上。</p>
<p>4.1.2 语法<br>
 1). 创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [ <span class="keyword">WITH</span> [</span><br><span class="line"><span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2. 查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看创建视图语句：SHOW CREATE VIEW 视图名称;</span><br><span class="line">查看视图数据：SELECT * FROM 视图名称 ...... ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3). 修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH</span><br><span class="line">[ CASCADED | LOCAL ] CHECK OPTION ]</span><br><span class="line">方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |</span><br><span class="line">LOCAL ] CHECK OPTIO]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4). 删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ..</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="41视图检查选项"><a class="markdownIt-Anchor" href="#41视图检查选项">#</a> 4.1 视图检查选项</h5>
<p>当使用 WITH CHECK OPTION 子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql 提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。<br>
1). CASCAD</p>
<p>级联。<br>
比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 cascaded，但是 v1 视图创建时未指定检查选项。 则在执行检查时，不仅会检查 v2，还会级联检查 v2 的关联视图 v1。</p>
<p>2). LOCAL<br>
 本地。<br>
比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 local ，但是 v1 视图创建时未指定检查选项。 则在执行检查时，只会检查 v2，不会检查 v2 的关联视图 v1。</p>
<h5 id="42视图的更新"><a class="markdownIt-Anchor" href="#42视图的更新">#</a> 4.2 视图的更新</h5>
<p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一<br>
项，则该视图不可更新：<br>
A. 聚合函数或窗口函数（SUM ()、 MIN ()、 MAX ()、 COUNT () 等）<br>
B. DISTINCT<br>
C. GROUP BY<br>
D. HAVING<br>
E. UNION 或者 UNION ALL</p>
<h5 id="43-存储过程"><a class="markdownIt-Anchor" href="#43-存储过程">#</a> 4.3 存储过程</h5>
<p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>
<h6 id="431-基本语法"><a class="markdownIt-Anchor" href="#431-基本语法">#</a> 4.3.1 基本语法</h6>
<p>1）创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2) 调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL 名称 ([ 参数 ]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3）查看</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>; <span class="comment">-- 查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ; <span class="comment">-- 查询某个存储过程的定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4）删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [ IF <span class="keyword">EXISTS</span> ] 存储过程名称 ；</span><br><span class="line">注意:</span><br><span class="line">在命令行中，执行创建存储过程的<span class="keyword">SQL</span>时，需要通过关键字 delimiter 指定<span class="keyword">SQL</span>语句的结束符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="432变量"><a class="markdownIt-Anchor" href="#432变量">#</a> 4.3.2 变量</h6>
<p>在 MySQL 中变量分为三种类型：系统变量、用户定义变量、局部变量</p>
<ul>
<li>
<p>系统变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看系统变量</span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ]VARIABLES ; <span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;......&#x27;</span>; <span class="comment">-- 可以通过LIKE模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] <span class="comment">-- 系统变量名;</span></span><br><span class="line">session 默认   <span class="keyword">global</span> 全局</span><br><span class="line"></span><br><span class="line">设置系统变量</span><br><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] 系统变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>]系统变量名 <span class="operator">=</span> 值 ；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用户定义变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sET</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr [, <span class="variable">@var_name</span> <span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var_name</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sELECT</span> <span class="variable">@var_name</span> ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>局部变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 变量类型 [<span class="keyword">DEFAULT</span> ... ] ;  <span class="comment">-- 声名</span></span><br><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名 ... ;<span class="comment">-- 赋值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="433-if"><a class="markdownIt-Anchor" href="#433-if">#</a> 4.3.3 if</h6>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">.....</span><br><span class="line">ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> <span class="comment">-- 可选</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">ELSE</span> <span class="comment">-- 可选</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">END</span> IF</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="434-参数"><a class="markdownIt-Anchor" href="#434-参数">#</a> 4.3.4 参数</h6>
<p>类型 							含义 															备注<br>
 IN 			该类参数作为输入，也就是需要调用时传入值 			默认<br>
 OUT 		该类参数作为输出，也就是该参数可以作为返回值<br>
 INOUT	 既可以作为输入参数，也可以作为输出参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])</span><br><span class="line">BEGIN</span><br><span class="line">-- SQL语句</span><br><span class="line">END ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="435case"><a class="markdownIt-Anchor" href="#435case">#</a> 4.3.5case</h6>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list</span></span><br><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line"><span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">[ <span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">[ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="436whilerepeat-loop"><a class="markdownIt-Anchor" href="#436whilerepeat-loop">#</a> 4.3.6while/repeat /loop</h6>
<p>while 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span></span><br><span class="line">WHILE 条件 DO</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> WHILE；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>repeat 语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line">		SQL逻辑...</span><br><span class="line">		UNTIL 条件</span><br><span class="line">END REPEAT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>loop 语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	SQL逻辑...</span><br><span class="line">END LOOP [end_label];</span><br><span class="line"></span><br><span class="line">LEAVE label; -- 退出指定标记的循环体</span><br><span class="line">ITERATE label; -- 直接进入下一次循环</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="437游标"><a class="markdownIt-Anchor" href="#437游标">#</a> 4.3.7 游标</h6>
<p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 游标名称 CURSOR FOR 查询语句 ; -- 声名</span><br><span class="line">OPEN 游标名称 ;  --打开</span><br><span class="line">FETCH 游标名称 INTO 变量 [, 变量 ] ; -- </span><br><span class="line">CLOSE 游标名称 ;  -- </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>条件处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE handler_action HANDLER FOR condition_value [, condition_value]</span><br><span class="line">... statement ;</span><br><span class="line">handler_action 的取值：</span><br><span class="line">CONTINUE: 继续执行当前程序</span><br><span class="line">EXIT: 终止执行当前程序</span><br><span class="line">condition_value 的取值：</span><br><span class="line">SQLSTATE sqlstate_value: 状态码，如 02000</span><br><span class="line">SQLWARNING: 所有以01开头的SQLSTATE代码的简写</span><br><span class="line">NOT FOUND: 所有以02开头的SQLSTATE代码的简写</span><br><span class="line">SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="438存储函数"><a class="markdownIt-Anchor" href="#438存储函数">#</a> 4.3.8 存储函数</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 存储函数名称 ([ 参数列表 ])</span><br><span class="line">RETURNS type [characteristic ...]</span><br><span class="line">BEGIN</span><br><span class="line">-- SQL语句</span><br><span class="line">RETURN ...;</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="44触发器"><a class="markdownIt-Anchor" href="#44触发器">#</a> 4.4 触发器</h5>
<p>触发器是与表有关的数据库对象，指在 insert/update/delete 之前 (BEFORE) 或之后 (AFTER)，触发并执行触发器中定义的 SQL 语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作 .<br>
 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
<h6 id="441语法"><a class="markdownIt-Anchor" href="#441语法">#</a> 4.4.1 语法</h6>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">		trigger_stmt ;</span><br><span class="line"><span class="keyword">END</span>;<span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS ;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name ; <span class="comment">-- 如果没有指定 schema_name，默认为当前数据库 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5锁"><a class="markdownIt-Anchor" href="#5锁">#</a> 5. 锁</h4>
<h5 id="51概述"><a class="markdownIt-Anchor" href="#51概述">#</a> 5.1 概述</h5>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL 中的锁，按照锁的粒度分，分为以下三类：<br>
全局锁：锁定数据库中的所有表。<br>
表级锁：每次操作锁住整张表。<br>
行级锁：每次操作锁住对应的行数据。</p>
<h5 id="52全局锁"><a class="markdownIt-Anchor" href="#52全局锁">#</a> 5.2 全局锁</h5>
<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞</p>
<p>语法</p>
<ol>
<li>
<p>加全局锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数据备份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot –p1234 itcast &gt; itcast.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlock tables ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 InnoDB 引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致<br>
性数据备份。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="53表级锁"><a class="markdownIt-Anchor" href="#53表级锁">#</a> 5.3 表级锁</h5>
<p>对于表级锁，主要分为以下三类：<br>
表锁<br>
元数据锁（meta data lock，MDL）<br>
意向锁</p>
<h6 id="531表锁"><a class="markdownIt-Anchor" href="#531表锁">#</a> 5.3.1 表锁</h6>
<p>对于表锁，分为两类：<br>
表共享读锁（read lock）  加入该所是，不影响读，会阻塞第二个客户端的的写<br>
表独占写锁（write lock） 加入该锁时，不影响客户 1 的读写，但是会阻塞客户端 2 的读写</p>
<p>语法：<br>
加锁：lock tables 表名… read/write。<br>
释放锁：unlock tables / 客户端断开连接 。</p>
<h6 id="532元数据锁"><a class="markdownIt-Anchor" href="#532元数据锁">#</a> 5.3.2 元数据锁</h6>
<p>meta data lock , 元数据锁，简写 MDL。<br>
MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免 DML 与 DDL 冲突，保证读写的正确性</p>
<table>
<thead>
<tr>
<th>对应 SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock tables xxx read /<br/>write</td>
<td>SHARED_READ_ONLY /<br/>SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select …<br/>lock in share mode</td>
<td>SHARED_READ</td>
<td>与 SHARED_READ、<br/>SHARED_WRITE 兼容，与<br/>EXCLUSIVE 互斥</td>
</tr>
<tr>
<td>insert 、update、<br/>delete、select … for<br/>update</td>
<td>SHARED_WRITE</td>
<td>与 SHARED_READ、<br/>SHARED_WRITE 兼容，与<br/>EXCLUSIVE 互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的 MDL 都互斥</td>
</tr>
</tbody>
</table>
<p>我们可以通过下面的 SQL，来查看数据库中的元数据锁的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select object_type,object_schema,object_name,lock_type,lock_duration from</span><br><span class="line">performance_schema.metadata_locks </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="533意向锁"><a class="markdownIt-Anchor" href="#533意向锁">#</a> 5.3.3 意向锁</h6>
<p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</p>
<p>意向共享锁 (IS): 由语句 select … lock in share mode 添加 。 与 表锁共享锁<br>
 (read) 兼容，与表锁排他锁 (write) 互斥。<br>
意向排他锁 (IX): 由 insert、update、delete、select…for update 添加 。与表锁共享锁 (read) 及排他锁 (write) 都互斥，意向锁之间不会互斥。</p>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放</p>
<h5 id="54行级锁"><a class="markdownIt-Anchor" href="#54行级锁">#</a> 5.4 行级锁</h5>
<p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。<br>
InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p>
<p>对于行级锁，主要分为以下三类：<br>
行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC、RR 隔离级别下都支持。<br>
间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持。<br>
临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持</p>
<h6 id="541行锁"><a class="markdownIt-Anchor" href="#541行锁">#</a> 5.4.1 行锁</h6>
<p>1). 介绍<br>
 InnoDB 实现了以下两种类型的行锁：<br>
共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。<br>
排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</p>
<table>
<thead>
<tr>
<th>QL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td>不加任何<br/>锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE<br/>MODE</td>
<td>共享锁</td>
<td>需要手动在 SELECT 之后加 LOCK IN SHARE</td>
</tr>
<tr>
<td>MODE<br/>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在 SELECT 之后加 FOR UPDATE</td>
</tr>
</tbody>
</table>
<p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。<br>
针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。<br>
InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时 就会升级为表锁</p>
<h6 id="542间隙锁临键锁"><a class="markdownIt-Anchor" href="#542间隙锁临键锁">#</a> 5.4.2 间隙锁 &amp; 临键锁</h6>
<p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。<br>
索引上的等值查询 (唯一索引)，给不存在的记录加锁时，优化为间隙锁 。<br>
索引上的等值查询 (非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。<br>
索引上的范围查询 (唯一索引)–会访问到不满足条件的第一个值为止。</p>
<hr>
<p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁</p>
<h4 id="6innodb引擎"><a class="markdownIt-Anchor" href="#6innodb引擎">#</a> 6.InnoDB 引擎</h4>
<h5 id="61逻辑存储结构"><a class="markdownIt-Anchor" href="#61逻辑存储结构">#</a> 6.1 逻辑存储结构</h5>
<p>1). 表空间</p>
<p>表空间是 InnoDB 存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table (在 8.0 版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个 mysql 实例可以对应多个表空间，用于存储记录、索引等数据。<br>
2). 段<br>
段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB 是索引组织表，数据段就是 B + 树的叶子节点， 索引段即为 B + 树的非叶子节点。段用来管理多个 Extent（区）。<br>
3). 区<br>
区，表空间的单元结构，每个区的大小为 1M。 默认情况下， InnoDB 存储引擎页大小为 16K， 即一个区中一共有 64 个连续的页。<br>
4). 页<br>
页，是 InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。<br>
5). 行<br>
行，InnoDB 存储引擎数据是按行进行存放的。<br>
在行中，默认有两个隐藏字段：</p>
<p>Trx_id：每次对某条记录进行改动时，都会把对应的事务 id 赋值给 trx_id 隐藏列。<br>
Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
<h5 id="62架构"><a class="markdownIt-Anchor" href="#62架构">#</a> 6.2 架构</h5>
<h6 id="621内存结构"><a class="markdownIt-Anchor" href="#621内存结构">#</a> 6.2.1 内存结构</h6>
<p>1). Buffer Pool<br>
InnoDB 存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的 I/O 效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘 I/O。在 InnoDB 的缓冲池中不仅缓存了索引页和数据页，还包含了 undo 页、插入缓存、自适应哈希索引以及 InnoDB 的锁信息等等。<br>
缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘 IO，加快处理速度。缓冲池以 Page 页为单位，底层采用链表数据结构管理 Page。根据状态，将 Page 分为三种类型：<br>
・free page：空闲 page，未被使用。<br>
・clean page：被使用 page，数据没有被修改过。<br>
・dirty page：脏页，被使用 page，数据被修改过，也中数据与磁盘的数据产生了不一致</p>
<p>2). Change Buffer<br>
Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行 DML 语句时，如果这些数据 Page<br>
 没有在 Buffer Pool 中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer<br>
 中，在未来数据被读取时，再将数据合并恢复到 Buffer Pool 中，再将合并后的数据刷新到磁盘中。</p>
<p>3). Adaptive Hash Index<br>
 自适应 hash 索引，用于优化对 Buffer Pool 数据的查询。MySQL 的 innoDB 引擎中虽然没有直接支持 hash 索引，但是给我们提供了一个功能就是这个自适应 hash 索引。因为前面我们讲到过，hash 索引在进行等值匹配时，一般性能是要高于 B + 树的，因为 hash 索引一般只需要一次 IO 即可，而 B + 树，可能需要几次匹配，所以 hash 索引的效率要高，但是 hash 索引又不适合做范围查询、模糊匹配等。<br>
InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下 hash 索引可以提升速度，则建立 hash 索引，称之为自适应 hash 索引。<br>
自适应哈希索引，无需人工干预，是系统根据情况自动完成。<br>
参数： adaptive_hash_index</p>
<p>4). Log Buffer<br>
Log Buffer：日志缓冲区，用来保存要写入到磁盘中的 log 日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。<br>
参数:<br>
innodb_log_buffer_size：缓冲区大小<br>
 innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：<br>
1: 日志在每次事务提交时写入并刷新到磁盘，默认值。<br>
0: 每秒将日志写入并刷新到磁盘一次。</p>
<p>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p>
<h6 id="622磁盘结构"><a class="markdownIt-Anchor" href="#622磁盘结构">#</a> 6.2.2 磁盘结构</h6>
<p>1). System Tablespace<br>
 系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在 MySQL5.x 版本中还包含 InnoDB 数据字典、undolog 等)<br>
 参数：innodb_data_file_path</p>
<p>2). File-Per-Table Tablespaces</p>
<p>如果开启了 innodb_file_per_table 开关 ，则每个表的文件表空间包含单个 InnoDB 表的数据和索引 ，并存储在文件系统上的单个数据文件中。<br>
开关参数：innodb_file_per_table ，该参数默认开启。</p>
<p>3). General Tablespaces<br>
 通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。<br>
A. 创建表空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLESPACE ts_name ADD DATAFILE &#x27;file_name&#x27; ENGINE = engine_name;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>B. 创建表时指定表空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE xxx ... TABLESPACE ts_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4). Undo Tablespaces<br>
 撤销表空间，MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小 16M），用于存储 undo log 日志。<br>
5). Temporary Tablespaces<br>
InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。<br>
6). Doublewrite Buffer Files</p>
<p>双写缓冲区，innoDB 引擎将数据页从 Buffer Pool 刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</p>
<p>7). Redo Log<br>
 重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo logbuffer）以及重做日志文件（redo log）, 前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用</p>
<h5 id="63事务原理"><a class="markdownIt-Anchor" href="#63事务原理">#</a> 6.3 事务原理</h5>
<p>1). 事务<br>
事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>2). 特性</p>
<p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。<br>
一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。<br>
隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环<br>
境下运行。<br>
持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p>
<h6 id="631redo-log"><a class="markdownIt-Anchor" href="#631redo-log">#</a> 6.3.1redo log</h6>
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）, 前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<h6 id="632undo-log"><a class="markdownIt-Anchor" href="#632undo-log">#</a> 6.3.2undo log</h6>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚 (保证事务的原子性) 和 MVCC (多版本并发控制) 。<br>
undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。<br>
Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于 MVCC。<br>
Undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。</p>
<h5 id="64mvcc"><a class="markdownIt-Anchor" href="#64mvcc">#</a> 6.4MVCC</h5>
<h6 id="641基本概念"><a class="markdownIt-Anchor" href="#641基本概念">#</a> 6.4.1 基本概念</h6>
<p>1). 当前读<br>
读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode (共享锁)，select …for update、update、insert、delete (排他锁) 都是一种当前读。</p>
<p>2). 快照读<br>
简单的 select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<br>
・Read Committed：每次 select，都生成一个快照读。<br>
・Repeatable Read：开启事务后第一个 select 语句才是快照读的地方。<br>
・Serializable：快照读会退化为当前读。</p>
<p><strong>3). MVCC</strong><br>
 全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 日志、readView。</p>
<h6 id="642隐式字段"><a class="markdownIt-Anchor" href="#642隐式字段">#</a> 6.4.2 隐式字段</h6>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB_TRX_ID</td>
<td>最近修改事务 ID，记录插入这条记录或最后一次修改该记录的事务 ID</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td>
</tr>
</tbody>
</table>
<h6 id="643readview"><a class="markdownIt-Anchor" href="#643readview">#</a> 6.4.3readview</h6>
<p>ReadView（读视图）是 快照读 SQL 执行时 MVCC 提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>m_ids</td>
<td>当前活跃的事务 ID 集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务 ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务 ID，当前最大事务 ID+1（因为事务 ID 是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView 创建者的事务 ID</td>
</tr>
</tbody>
<tbody>
<tr>
<td>条件</td>
<td>是否可以访问</td>
<td>说明</td>
</tr>
<tr>
<td>--------------------------------------</td>
<td>----------------------------------------------</td>
<td>-----------------------------------------------</td>
</tr>
<tr>
<td>trx_id ==creator_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据是当前这个事务更改的。</td>
</tr>
<tr>
<td>trx_id &lt; min_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据已经提交了。</td>
</tr>
<tr>
<td>trx_id &gt; max_trx_id</td>
<td>不可以访问该版本</td>
<td>成立，说明该事务是在<br/>ReadView 生成后才开启。</td>
</tr>
<tr>
<td>min_trx_id &lt;= trx_id<br/>&lt;= max_trx_id</td>
<td>如果 trx_id 不在 m_ids 中，<br/>是可以访问该版本的</td>
<td>成立，说明数据已经提交。</td>
</tr>
</tbody>
</table>
<h6 id="644实现原理"><a class="markdownIt-Anchor" href="#644实现原理">#</a> 6.4.4 实现原理</h6>
<p>MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决 <code>读写冲突</code> ，它的实现原理主要是依赖记录中的  <code>3个隐式字段</code> ， <code>undo日志</code>  ， <code>Read View</code>  来实现的</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2025-07-14 22:18:15" itemprop="dateModified" datetime="2025-07-14T22:18:15+08:00">2025-07-14</time>
  </span>
  <span id="2025/07/14/demo6-1/" class="item leancloud_visitors" data-flag-title="MySQL" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wxpay.jpg" alt="李涛 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/zifubao.jpg" alt="李涛 支付宝">
        <p>支付宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>李涛 <i class="ic i-at"><em>@</em></i>scidag
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2025/07/14/demo6-1/" title="MySQL">http://example.com/2025/07/14/demo6-1/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2025/07/14/demo6/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicljgocqbj20zk0m8e81.jpg" title="mybatis plus">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>mybatis plus</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2025/07/14/demo7/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipewkhf1zj20zk0m81kx.jpg" title="redis">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>redis</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> 1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2sql"><span class="toc-number">2.</span> <span class="toc-text"> 2.SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1ddl"><span class="toc-number">2.1.</span> <span class="toc-text"> 1.DDL</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 1). 查询所有数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 2). 查询当前数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 3). 创建数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 4）删除数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.5.</span> <span class="toc-text"> 5）切换数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.6.</span> <span class="toc-text"> ６）创建表结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.7.</span> <span class="toc-text"> 7）修改表结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="toc-number">2.1.8.</span> <span class="toc-text"> 8）删除表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2dml-insert-update-delete"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.DML （insert  update  delete）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#insert"><span class="toc-number">2.2.1.</span> <span class="toc-text"> insert</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#update"><span class="toc-number">2.2.2.</span> <span class="toc-text"> update</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#delete"><span class="toc-number">2.2.3.</span> <span class="toc-text"> delete</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3dql"><span class="toc-number">2.3.</span> <span class="toc-text"> 3.DQL</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#select"><span class="toc-number">2.3.1.</span> <span class="toc-text"> select</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4dcl"><span class="toc-number">2.4.</span> <span class="toc-text"> 4.DCL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text"> 3. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text"> 1. 字符串函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.2.</span> <span class="toc-text"> 2. 数值函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.3.</span> <span class="toc-text"> 3. 日期函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.4.</span> <span class="toc-text"> 4. 流程函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.</span> <span class="toc-text"> 4. 约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.</span> <span class="toc-text"> 5. 多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">5.0.1.</span> <span class="toc-text"> 1. 多表关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.0.2.</span> <span class="toc-text"> 2. 多表查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text"> 6. 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E7%AE%80%E4%BB%8B"><span class="toc-number">6.0.1.</span> <span class="toc-text"> 1. 简介</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">6.0.2.</span> <span class="toc-text"> 2. 事务操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">6.0.3.</span> <span class="toc-text"> 3. 事务的四大特性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.4.</span> <span class="toc-text"> 4. 并发事务问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">6.0.5.</span> <span class="toc-text"> 5. 事务的隔离级别</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E9%98%B6"><span class="toc-number"></span> <span class="toc-text"> 二。进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text"> 1. 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1 MySQL 体系结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2 存储引擎介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13innodb"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3Innodb</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 1). 介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 2). 特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 3). 文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 4). 逻辑存储结构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-myisam"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4   MyISAM</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 1). 介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9-2"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 2). 特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6-2"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 3). 文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15memory"><span class="toc-number">1.5.</span> <span class="toc-text"> 1.5Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 1). 介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9-3"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 2). 特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 3). 文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text"> 1.6 区别及特点 (面试题)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%80%89%E6%8B%A9"><span class="toc-number">1.7.</span> <span class="toc-text"> 1.7 存储引擎选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%B4%A2%E5%BC%95"><span class="toc-number">2.</span> <span class="toc-text"> 2. 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2 索引结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3 索引分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.</span> <span class="toc-text"> 2.4 聚集索引 &amp; 二级索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text"> 2.5 索引语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-sql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.6.</span> <span class="toc-text"> 2.6 SQL 性能分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27profile%E8%AF%A6%E6%83%85"><span class="toc-number">2.7.</span> <span class="toc-text"> 2.7profile 详情</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-explain"><span class="toc-number">2.8.</span> <span class="toc-text"> 2.8 explain</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.9.</span> <span class="toc-text"> 2.9 索引使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#291%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">2.9.1.</span> <span class="toc-text"> 2.9.1 最左前缀法则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#292%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.9.2.</span> <span class="toc-text"> 2.9.2 范围查询</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#210%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">2.10.</span> <span class="toc-text"> 2.10 单列索引与联合索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#211%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.11.</span> <span class="toc-text"> 2.11 索引设计原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3sql%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text"> 3.SQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#31%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 插入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 主键优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33order-by%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3order by 优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34group-by"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4group by</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35-limit"><span class="toc-number">3.5.</span> <span class="toc-text"> 3.5 limit</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text"> 4. 视图，存储过程，触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#41%E8%A7%86%E5%9B%BE%E6%A3%80%E6%9F%A5%E9%80%89%E9%A1%B9"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1 视图检查选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#42%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2 视图的更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#43-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3 存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#431-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 4.3.1 基本语法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#432%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 4.3.2 变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#433-if"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 4.3.3 if</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#434-%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text"> 4.3.4 参数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#435case"><span class="toc-number">4.3.5.</span> <span class="toc-text"> 4.3.5case</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#436whilerepeat-loop"><span class="toc-number">4.3.6.</span> <span class="toc-text"> 4.3.6while&#x2F;repeat &#x2F;loop</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#437%E6%B8%B8%E6%A0%87"><span class="toc-number">4.3.7.</span> <span class="toc-text"> 4.3.7 游标</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#438%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.8.</span> <span class="toc-text"> 4.3.8 存储函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#44%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text"> 4.4 触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#441%E8%AF%AD%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 4.4.1 语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text"> 5. 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#51%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#52%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2 全局锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#53%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3 表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#531%E8%A1%A8%E9%94%81"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 5.3.1 表锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#532%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 5.3.2 元数据锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#533%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">5.3.3.</span> <span class="toc-text"> 5.3.3 意向锁</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#54%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">5.4.</span> <span class="toc-text"> 5.4 行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#541%E8%A1%8C%E9%94%81"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 5.4.1 行锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#542%E9%97%B4%E9%9A%99%E9%94%81%E4%B8%B4%E9%94%AE%E9%94%81"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 5.4.2 间隙锁 &amp; 临键锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6innodb%E5%BC%95%E6%93%8E"><span class="toc-number">6.</span> <span class="toc-text"> 6.InnoDB 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#61%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text"> 6.1 逻辑存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#62%E6%9E%B6%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text"> 6.2 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#621%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 6.2.1 内存结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#622%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.2.</span> <span class="toc-text"> 6.2.2 磁盘结构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#63%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text"> 6.3 事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#631redo-log"><span class="toc-number">6.3.1.</span> <span class="toc-text"> 6.3.1redo log</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#632undo-log"><span class="toc-number">6.3.2.</span> <span class="toc-text"> 6.3.2undo log</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#64mvcc"><span class="toc-number">6.4.</span> <span class="toc-text"> 6.4MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#641%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.4.1.</span> <span class="toc-text"> 6.4.1 基本概念</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#642%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">6.4.2.</span> <span class="toc-text"> 6.4.2 隐式字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#643readview"><span class="toc-number">6.4.3.</span> <span class="toc-text"> 6.4.3readview</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#644%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.4.</span> <span class="toc-text"> 6.4.4 实现原理</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="李涛"
      data-src="/images/myavatar.jpg">
  <p class="name" itemprop="name">李涛</p>
  <div class="description" itemprop="description">李涛的个人博客</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">15</span>
        <span class="name">文章</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2025/07/14/demo6/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2025/07/14/demo7/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/14/demo6-1/" title="MySQL">MySQL</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/16/demo8/" title="session and cookie">session and cookie</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/14/demo4/" title="spring mvc">spring mvc</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/14/demo3/" title="spring">spring</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/14/demo2/" title="Mybatis">Mybatis</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/20/demo10/" title="nacos">nacos</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/14/demo6/" title="mybatis plus">mybatis plus</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/14/demo5/" title="Spring Boot">Spring Boot</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/14/demo1/" title="jdbc">jdbc</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2025/07/16/demo9/" title="docker">docker</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李涛 @ scidag的个人博客</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2025/07/14/demo6-1/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
